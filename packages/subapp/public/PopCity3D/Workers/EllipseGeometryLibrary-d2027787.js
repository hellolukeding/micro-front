define(["exports","./Matrix3-6db83cde","./Math-ee85dd73","./Transforms-ebbb6d22"],(function(t,a,e,n){"use strict";const i={},r=new a.Cartesian3,s=new a.Cartesian3,o=new n.Quaternion,l=new a.Matrix3;function c(t,e,i,c,C,y,u,m,h,x){const M=t+e;a.Cartesian3.multiplyByScalar(c,Math.cos(M),r),a.Cartesian3.multiplyByScalar(i,Math.sin(M),s),a.Cartesian3.add(r,s,r);let d=Math.cos(t);d*=d;let z=Math.sin(t);z*=z;const f=y/Math.sqrt(u*d+C*z)/m;return n.Quaternion.fromAxisAngle(r,f,o),a.Matrix3.fromQuaternion(o,l),a.Matrix3.multiplyByVector(l,h,x),a.Cartesian3.normalize(x,x),a.Cartesian3.multiplyByScalar(x,m,x),x}const C=new a.Cartesian3,y=new a.Cartesian3,u=new a.Cartesian3,m=new a.Cartesian3;i.raisePositionsToHeight=function(t,e,n){const i=e.ellipsoid,r=e.height,s=e.extrudedHeight,o=n?t.length/3*2:t.length/3,l=new Float64Array(3*o),c=t.length,h=n?c:0;for(let e=0;e<c;e+=3){const o=e+1,c=e+2,x=a.Cartesian3.fromArray(t,e,C);i.scaleToGeodeticSurface(x,x);const M=a.Cartesian3.clone(x,y),d=i.geodeticSurfaceNormal(x,m),z=a.Cartesian3.multiplyByScalar(d,r,u);a.Cartesian3.add(x,z,x),n&&(a.Cartesian3.multiplyByScalar(d,s,z),a.Cartesian3.add(M,z,M),l[e+h]=M.x,l[o+h]=M.y,l[c+h]=M.z),l[e]=x.x,l[o]=x.y,l[c]=x.z}return l};const h=new a.Cartesian3,x=new a.Cartesian3,M=new a.Cartesian3;i.computeEllipsePositions=function(t,n,i){const r=t.semiMinorAxis,s=t.semiMajorAxis,o=t.rotation,l=t.center,m=8*t.granularity,d=r*r,z=s*s,f=s*r,_=a.Cartesian3.magnitude(l),O=a.Cartesian3.normalize(l,h);let p=a.Cartesian3.cross(a.Cartesian3.UNIT_Z,l,x);p=a.Cartesian3.normalize(p,p);const w=a.Cartesian3.cross(O,p,M);let P=1+Math.ceil(e.CesiumMath.PI_OVER_TWO/m);const T=e.CesiumMath.PI_OVER_TWO/(P-1);let I=e.CesiumMath.PI_OVER_TWO-P*T;I<0&&(P-=Math.ceil(Math.abs(I)/T));const g=n?new Array(3*(P*(P+2)*2)):void 0;let E=0,V=C,A=y;const R=4*P*3;let W=R-1,S=0;const b=i?new Array(R):void 0;let B,v,Q,G,H;for(I=e.CesiumMath.PI_OVER_TWO,V=c(I,o,w,p,d,f,z,_,O,V),n&&(g[E++]=V.x,g[E++]=V.y,g[E++]=V.z),i&&(b[W--]=V.z,b[W--]=V.y,b[W--]=V.x),I=e.CesiumMath.PI_OVER_TWO-T,B=1;B<P+1;++B){if(V=c(I,o,w,p,d,f,z,_,O,V),A=c(Math.PI-I,o,w,p,d,f,z,_,O,A),n){for(g[E++]=V.x,g[E++]=V.y,g[E++]=V.z,Q=2*B+2,v=1;v<Q-1;++v)G=v/(Q-1),H=a.Cartesian3.lerp(V,A,G,u),g[E++]=H.x,g[E++]=H.y,g[E++]=H.z;g[E++]=A.x,g[E++]=A.y,g[E++]=A.z}i&&(b[W--]=V.z,b[W--]=V.y,b[W--]=V.x,b[S++]=A.x,b[S++]=A.y,b[S++]=A.z),I=e.CesiumMath.PI_OVER_TWO-(B+1)*T}for(B=P;B>1;--B){if(I=e.CesiumMath.PI_OVER_TWO-(B-1)*T,V=c(-I,o,w,p,d,f,z,_,O,V),A=c(I+Math.PI,o,w,p,d,f,z,_,O,A),n){for(g[E++]=V.x,g[E++]=V.y,g[E++]=V.z,Q=2*(B-1)+2,v=1;v<Q-1;++v)G=v/(Q-1),H=a.Cartesian3.lerp(V,A,G,u),g[E++]=H.x,g[E++]=H.y,g[E++]=H.z;g[E++]=A.x,g[E++]=A.y,g[E++]=A.z}i&&(b[W--]=V.z,b[W--]=V.y,b[W--]=V.x,b[S++]=A.x,b[S++]=A.y,b[S++]=A.z)}I=e.CesiumMath.PI_OVER_TWO,V=c(-I,o,w,p,d,f,z,_,O,V);const N={};return n&&(g[E++]=V.x,g[E++]=V.y,g[E++]=V.z,N.positions=g,N.numPts=P),i&&(b[W--]=V.z,b[W--]=V.y,b[W--]=V.x,N.outerPositions=b),N};var d=i;t.EllipseGeometryLibrary=d}));

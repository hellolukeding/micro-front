/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.109
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

import{a as Ne}from"./chunk-6E4HESUV.js";import{a as q}from"./chunk-LV5JNJW5.js";import{a as Ct}from"./chunk-4HZMYYV5.js";import{a as Le}from"./chunk-BPHJAOXV.js";import{a as Ce}from"./chunk-7OXYSRTX.js";import{a as te}from"./chunk-SOSOLPNH.js";import{b as Qt}from"./chunk-I3I5OTO3.js";import{a as jt}from"./chunk-2ZWKWEVH.js";import{c as Ie,d as zt}from"./chunk-EEJ2JXMA.js";import{a as At,d as U,f as Kt,g as Ee,h as xe}from"./chunk-C5WQKYCA.js";import"./chunk-I5APSYNV.js";import{c as Y,d as Nt}from"./chunk-IGNK4GOL.js";import{a as Bt}from"./chunk-73TRCFHO.js";import{a as t,b as S,c as j,d as vt}from"./chunk-ZEOJZXG5.js";import{a as h}from"./chunk-RSM3RCYG.js";import"./chunk-6FRIJAB3.js";import"./chunk-HESD226B.js";import{a as E}from"./chunk-3G6A2N63.js";import{a as St,b as et}from"./chunk-BJ5TGS5X.js";import{e as m}from"./chunk-FZAERGXZ.js";function rt(e){e=E(e,E.EMPTY_OBJECT),m(e.tileInfo)&&m(e.tileInfo.spatialReference)&&m(e.tileInfo.spatialReference.wkid)&&e.tileInfo.spatialReference.wkid==4490?(this._tileInfo=e.tileInfo,this._ellipsoid=E(e.ellipsoid,j.CGCS2000),this._rectangle=E(e.rectangle,Y.fromDegrees(-180,-90,180,90)),this._numberOfLevelZeroTilesX=E(e.numberOfLevelZeroTilesX,4),this._numberOfLevelZeroTilesY=E(e.numberOfLevelZeroTilesY,2)):(this._ellipsoid=E(e.ellipsoid,j.WGS84),this._rectangle=E(e.rectangle,Y.MAX_VALUE),this._numberOfLevelZeroTilesX=E(e.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=E(e.numberOfLevelZeroTilesY,1)),this._projection=new At(this._ellipsoid)}Object.defineProperties(rt.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}});rt.prototype.getNumberOfXTilesAtLevel=function(e){if(m(this._tileInfo)){let r=this._tileInfo.lods.filter(function(n){return n.level===e})[0].resolution;return Math.round(h.toDegrees(h.TWO_PI)/(this._tileInfo.rows*r))}else return this._numberOfLevelZeroTilesX<<e};rt.prototype.getNumberOfYTilesAtLevel=function(e){if(m(this._tileInfo)){let r=this._tileInfo.lods.filter(function(n){return n.level===e})[0].resolution;return Math.round(h.toDegrees(h.TWO_PI/2)/(this._tileInfo.cols*r))}else return this._numberOfLevelZeroTilesY<<e};rt.prototype.rectangleToNativeRectangle=function(e,o){et.defined("rectangle",e);let r=h.toDegrees(e.west),n=h.toDegrees(e.south),i=h.toDegrees(e.east),a=h.toDegrees(e.north);return m(o)?(o.west=r,o.south=n,o.east=i,o.north=a,o):new Y(r,n,i,a)};rt.prototype.tileXYToNativeRectangle=function(e,o,r,n){let i=this.tileXYToRectangle(e,o,r,n);return i.west=h.toDegrees(i.west),i.south=h.toDegrees(i.south),i.east=h.toDegrees(i.east),i.north=h.toDegrees(i.north),i};rt.prototype.tileXYToRectangle=function(e,o,r,n){let i=this._rectangle,a=0,c=0,l=0,s=0;if(m(this._tileInfo)){let f=this._tileInfo.lods.filter(function(w){return w.level===r})[0].resolution;l=this._tileInfo.origin.y-o*(this._tileInfo.cols*f),a=this._tileInfo.origin.x+e*(this._tileInfo.rows*f),s=this._tileInfo.origin.y-(o+1)*(this._tileInfo.cols*f),c=this._tileInfo.origin.x+(e+1)*(this._tileInfo.rows*f),a=h.toRadians(a),l=h.toRadians(l),c=h.toRadians(c),s=h.toRadians(s)}else{let d=this.getNumberOfXTilesAtLevel(r),f=this.getNumberOfYTilesAtLevel(r),w=i.width/d;a=e*w+i.west,c=(e+1)*w+i.west;let g=i.height/f;l=i.north-o*g,s=i.north-(o+1)*g}return m(n)||(n=new Y(a,s,c,l)),n.west=a,n.south=s,n.east=c,n.north=l,n};rt.prototype.positionToTileXY=function(e,o,r){let n=this._rectangle;if(!Y.contains(n,e))return;if(m(this._tileInfo)){let g=this._tileInfo.lods.filter(function(X){return X.level===o})[0].resolution,H=h.toDegrees(e.longitude),O=h.toDegrees(e.latitude),D=Math.floor((H-this._tileInfo.origin.x)/(this._tileInfo.rows*g)),v=Math.floor((this._tileInfo.origin.y-O)/(this._tileInfo.cols*g));return new Nt(D,v)}let i=this.getNumberOfXTilesAtLevel(o),a=this.getNumberOfYTilesAtLevel(o),c=n.width/i,l=n.height/a,s=e.longitude;n.east<n.west&&(s+=h.TWO_PI);let d=(s-n.west)/c|0;d>=i&&(d=i-1);let f=(n.north-e.latitude)/l|0;return f>=a&&(f=a-1),m(r)?(r.x=d,r.y=f,r):new Nt(d,f)};var Oe=rt;var De=new t,He=new t,ke=new S,ee=new t,hn=new t,ye=new U,fn=new Oe,Lt=[new S,new S,new S,new S],Ot=new Nt,T={};T.initialize=function(){let e=T._initPromise;return m(e)||(e=Ee.fetchJson(xe("Assets/approximateTerrainHeights.json")).then(function(o){T._terrainHeights=o}),T._initPromise=e),e};T.getMinimumMaximumHeights=function(e,o){if(et.defined("rectangle",e),!m(T._terrainHeights))throw new St("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");o=E(o,j.WGS84);let r=Me(e),n=T._defaultMinTerrainHeight,i=T._defaultMaxTerrainHeight;if(m(r)){let a=`${r.level}-${r.x}-${r.y}`,c=T._terrainHeights[a];m(c)&&(n=c[0],i=c[1]),o.cartographicToCartesian(Y.northeast(e,ke),De),o.cartographicToCartesian(Y.southwest(e,ke),He),t.midpoint(He,De,ee);let l=o.scaleToGeodeticSurface(ee,hn);if(m(l)){let s=t.distance(ee,l);n=Math.min(n,-s)}else n=T._defaultMinTerrainHeight}return n=Math.max(T._defaultMinTerrainHeight,n),{minimumTerrainHeight:n,maximumTerrainHeight:i}};T.getBoundingSphere=function(e,o){if(et.defined("rectangle",e),!m(T._terrainHeights))throw new St("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");o=E(o,j.WGS84);let r=Me(e),n=T._defaultMaxTerrainHeight;if(m(r)){let a=`${r.level}-${r.x}-${r.y}`,c=T._terrainHeights[a];m(c)&&(n=c[1])}let i=U.fromRectangle3D(e,o,0);return U.fromRectangle3D(e,o,n,ye),U.union(i,ye,i)};function Me(e){S.fromRadians(e.east,e.north,0,Lt[0]),S.fromRadians(e.west,e.north,0,Lt[1]),S.fromRadians(e.east,e.south,0,Lt[2]),S.fromRadians(e.west,e.south,0,Lt[3]);let o=0,r=0,n=0,i=0,a=T._terrainHeightsMaxLevel,c;for(c=0;c<=a;++c){let l=!1;for(let s=0;s<4;++s){let d=Lt[s];if(fn.positionToTileXY(d,c,Ot),s===0)n=Ot.x,i=Ot.y;else if(n!==Ot.x||i!==Ot.y){l=!0;break}}if(l)break;o=n,r=i}if(c!==0)return{x:o,y:r,level:c>a?a:c-1}}T._terrainHeightsMaxLevel=6;T._defaultMaxTerrainHeight=9e3;T._defaultMinTerrainHeight=-1e5;T._terrainHeights=void 0;T._initPromise=void 0;Object.defineProperties(T,{initialized:{get:function(){return m(T._terrainHeights)}}});var Xt=T;var le=[At,Ne],dn=le.length,Ke=Math.cos(h.toRadians(30)),Re=Math.cos(h.toRadians(150)),Qe=0,tn=1e3;function ct(e){e=E(e,E.EMPTY_OBJECT);let o=e.positions;if(!m(o)||o.length<2)throw new St("At least two positions are required.");if(m(e.arcType)&&e.arcType!==q.GEODESIC&&e.arcType!==q.RHUMB)throw new St("Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.");this.width=E(e.width,1),this._positions=o,this.granularity=E(e.granularity,9999),this.loop=E(e.loop,!1),this.arcType=E(e.arcType,q.GEODESIC),this._ellipsoid=j.WGS84,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(ct.prototype,{packedLength:{get:function(){return 1+this._positions.length*3+1+1+1+j.packedLength+1+1}}});ct.setProjectionAndEllipsoid=function(e,o){let r=0;for(let n=0;n<dn;n++)if(o instanceof le[n]){r=n;break}e._projectionIndex=r,e._ellipsoid=o.ellipsoid};var pn=new t,be=new t,Pe=new t;function se(e,o,r,n,i){let a=P(n,e,0,pn),c=P(n,e,r,be),l=P(n,o,0,Pe),s=nt(c,a,be),d=nt(l,a,Pe);return t.cross(d,s,i),t.normalize(i,i)}var mn=new S,gn=new t,un=new t,wn=new t;function ne(e,o,r,n,i,a,c,l,s,d,f){if(i===0)return;let w;a===q.GEODESIC?w=new Le(e,o,c):a===q.RHUMB&&(w=new te(e,o,c));let g=w.surfaceDistance;if(g<i)return;let H=se(e,o,n,c,wn),O=Math.ceil(g/i),D=g/O,v=D,X=O-1,p=l.length;for(let F=0;F<X;F++){let B=w.interpolateUsingSurfaceDistance(v,mn),M=P(c,B,r,gn),k=P(c,B,n,un);t.pack(H,l,p),t.pack(M,s,p),t.pack(k,d,p),f.push(B.latitude),f.push(B.longitude),p+=3,v+=D}}var oe=new S;function P(e,o,r,n){return S.clone(o,oe),oe.height=r,S.toCartesian(oe,e,n)}ct.pack=function(e,o,r){et.typeOf.object("value",e),et.defined("array",o);let n=E(r,0),i=e._positions,a=i.length;o[n++]=a;for(let c=0;c<a;++c){let l=i[c];t.pack(l,o,n),n+=3}return o[n++]=e.granularity,o[n++]=e.loop?1:0,o[n++]=e.arcType,j.pack(e._ellipsoid,o,n),n+=j.packedLength,o[n++]=e._projectionIndex,o[n++]=e._scene3DOnly?1:0,o};ct.unpack=function(e,o,r){et.defined("array",e);let n=E(o,0),i=e[n++],a=new Array(i);for(let g=0;g<i;g++)a[g]=t.unpack(e,n),n+=3;let c=e[n++],l=e[n++]===1,s=e[n++],d=j.unpack(e,n);n+=j.packedLength;let f=e[n++],w=e[n++]===1;return m(r)||(r=new ct({positions:a})),r._positions=a,r.granularity=c,r.loop=l,r.arcType=s,r._ellipsoid=d,r._projectionIndex=f,r._scene3DOnly=w,r};function nt(e,o,r){return t.subtract(e,o,r),t.normalize(r,r),r}function Ae(e,o,r,n){return n=nt(e,o,n),n=t.cross(n,r,n),n=t.normalize(n,n),n=t.cross(r,n,n),n}var Sn=new t,Tn=new t,_n=new t,en=new t,En=0,xn=-1;function ie(e,o,r,n,i){let a=nt(r,o,en),c=Ae(e,o,a,Sn),l=Ae(n,o,a,Tn);if(h.equalsEpsilon(t.dot(c,l),xn,h.EPSILON5))return i=t.cross(a,c,i),i=t.normalize(i,i),i;i=t.add(l,c,i),i=t.normalize(i,i);let s=t.cross(a,i,_n);return t.dot(l,s)<En&&(i=t.negate(i,i)),i}var Wt=jt.fromPointNormal(t.ZERO,t.UNIT_Y),In=new t,Nn=new t,Cn=new t,Ln=new t,On=new t,Yt=new t,Ft=new S,ve=new S,Be=new S;ct.createGeometry=function(e){let o=!e._scene3DOnly,r=e.loop,n=e._ellipsoid,i=e.granularity,a=e.arcType,c=new le[e._projectionIndex](n),l=Qe,s=tn,d,f,w=e._positions,g=w.length;g===2&&(r=!1);let H,O,D,v,X=new te(void 0,void 0,n),p,F,B,M=[w[0]];for(f=0;f<g-1;f++)H=w[f],O=w[f+1],p=Qt.lineSegmentPlane(H,O,Wt,Yt),m(p)&&!t.equalsEpsilon(p,H,h.EPSILON7)&&!t.equalsEpsilon(p,O,h.EPSILON7)&&(e.arcType===q.GEODESIC?M.push(t.clone(p)):e.arcType===q.RHUMB&&(B=n.cartesianToCartographic(p,Ft).longitude,D=n.cartesianToCartographic(H,Ft),v=n.cartesianToCartographic(O,ve),X.setEndPoints(D,v),F=X.findIntersectionWithLongitude(B,Be),p=n.cartographicToCartesian(F,Yt),m(p)&&!t.equalsEpsilon(p,H,h.EPSILON7)&&!t.equalsEpsilon(p,O,h.EPSILON7)&&M.push(t.clone(p)))),M.push(O);r&&(H=w[g-1],O=w[0],p=Qt.lineSegmentPlane(H,O,Wt,Yt),m(p)&&!t.equalsEpsilon(p,H,h.EPSILON7)&&!t.equalsEpsilon(p,O,h.EPSILON7)&&(e.arcType===q.GEODESIC?M.push(t.clone(p)):e.arcType===q.RHUMB&&(B=n.cartesianToCartographic(p,Ft).longitude,D=n.cartesianToCartographic(H,Ft),v=n.cartesianToCartographic(O,ve),X.setEndPoints(D,v),F=X.findIntersectionWithLongitude(B,Be),p=n.cartographicToCartesian(F,Yt),m(p)&&!t.equalsEpsilon(p,H,h.EPSILON7)&&!t.equalsEpsilon(p,O,h.EPSILON7)&&M.push(t.clone(p)))));let k=M.length,N=new Array(k);for(f=0;f<k;f++){let W=S.fromCartesian(M[f],n);W.height=0,N[f]=W}if(N=Ce(N,S.equalsEpsilon),k=N.length,k<2)return;let y=[],A=[],z=[],x=[],I=In,L=Nn,C=Cn,G=Ln,R=On,u=N[0],V=N[1],Ht=N[k-1];for(I=P(n,Ht,l,I),G=P(n,V,l,G),L=P(n,u,l,L),C=P(n,u,s,C),r?R=ie(I,L,C,G,R):R=se(u,V,s,n,R),t.pack(R,A,0),t.pack(L,z,0),t.pack(C,x,0),y.push(u.latitude),y.push(u.longitude),ne(u,V,l,s,i,a,n,A,z,x,y),f=1;f<k-1;++f){I=t.clone(L,I),L=t.clone(G,L);let W=N[f];P(n,W,s,C),P(n,N[f+1],l,G),ie(I,L,C,G,R),d=A.length,t.pack(R,A,d),t.pack(L,z,d),t.pack(C,x,d),y.push(W.latitude),y.push(W.longitude),ne(N[f],N[f+1],l,s,i,a,n,A,z,x,y)}let b=N[k-1],Tt=N[k-2];if(L=P(n,b,l,L),C=P(n,b,s,C),r){let W=N[0];I=P(n,Tt,l,I),G=P(n,W,l,G),R=ie(I,L,C,G,R)}else R=se(Tt,b,s,n,R);if(d=A.length,t.pack(R,A,d),t.pack(L,z,d),t.pack(C,x,d),y.push(b.latitude),y.push(b.longitude),r){for(ne(b,u,l,s,i,a,n,A,z,x,y),d=A.length,f=0;f<3;++f)A[d+f]=A[f],z[d+f]=z[f],x[d+f]=x[f];y.push(u.latitude),y.push(u.longitude)}return Qn(r,c,z,x,A,y,o)};var Dn=new t,Hn=new vt,kn=new Kt;function ze(e,o,r,n){let i=nt(r,o,Dn),a=t.dot(i,e);if(a>Ke||a<Re){let c=nt(n,r,en),l=a<Re?h.PI_OVER_TWO:-h.PI_OVER_TWO,s=Kt.fromAxisAngle(c,l,kn),d=vt.fromQuaternion(s,Hn);return vt.multiplyByVector(d,e,e),!0}return!1}var je=new S,yn=new t,Xe=new t;function Dt(e,o,r,n,i){let a=S.toCartesian(o,e._ellipsoid,yn),c=t.add(a,r,Xe),l=!1,s=e._ellipsoid,d=s.cartesianToCartographic(c,je);Math.abs(o.longitude-d.longitude)>h.PI_OVER_TWO&&(l=!0,c=t.subtract(a,r,Xe),d=s.cartesianToCartographic(c,je)),d.height=0;let f=e.project(d,i);return i=t.subtract(f,n,i),i.z=0,i=t.normalize(i,i),l&&t.negate(i,i),i}var Mn=new t,Ye=new t;function Fe(e,o,r,n,i,a){let c=t.subtract(o,e,Mn);t.normalize(c,c);let l=r-Qe,s=t.multiplyByScalar(c,l,Ye);t.add(e,s,i);let d=n-tn;s=t.multiplyByScalar(c,d,Ye),t.add(o,s,a)}var Rn=new t;function Gt(e,o){let r=jt.getPointDistance(Wt,e),n=jt.getPointDistance(Wt,o),i=Rn;h.equalsEpsilon(r,0,h.EPSILON2)?(i=nt(o,e,i),t.multiplyByScalar(i,h.EPSILON2,i),t.add(e,i,e)):h.equalsEpsilon(n,0,h.EPSILON2)&&(i=nt(e,o,i),t.multiplyByScalar(i,h.EPSILON2,i),t.add(o,i,o))}function bn(e,o){let r=Math.abs(e.longitude),n=Math.abs(o.longitude);if(h.equalsEpsilon(r,h.PI,h.EPSILON11)){let i=h.sign(o.longitude);return e.longitude=i*(r-h.EPSILON11),1}else if(h.equalsEpsilon(n,h.PI,h.EPSILON11)){let i=h.sign(e.longitude);return o.longitude=i*(n-h.EPSILON11),2}return 0}var nn=new S,on=new S,Ge=new t,re=new t,We=new t,Ue=new t,Pn=new t,Ze=new t,An=[nn,on],vn=new Y,Bn=new t,zn=new t,jn=new t,Xn=new t,Yn=new t,Fn=new t,ae=new t,ce=new t,Gn=new t,Wn=new t,Un=new t,qe=new t,Zn=new t,qn=new t,Vn=new Ct,$n=new Ct,Ve=new t,Jn=new t,$e=new t,Kn=[new U,new U],rn=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],Je=rn.length;function Qn(e,o,r,n,i,a,c){let l,s,d=o._ellipsoid,f=r.length/3-1,w=f*8,g=w*4,H=f*36,O=w>65535?new Uint32Array(H):new Uint16Array(H),D=new Float64Array(w*3),v=new Float32Array(g),X=new Float32Array(g),p=new Float32Array(g),F=new Float32Array(g),B=new Float32Array(g),M,k,N,y;c&&(M=new Float32Array(g),k=new Float32Array(g),N=new Float32Array(g),y=new Float32Array(w*2));let A=a.length/2,z=0,x=nn;x.height=0;let I=on;I.height=0;let L=Ge,C=re;if(c)for(s=0,l=1;l<A;l++)x.latitude=a[s],x.longitude=a[s+1],I.latitude=a[s+2],I.longitude=a[s+3],L=o.project(x,L),C=o.project(I,C),z+=t.distance(L,C),s+=2;let G=n.length/3;C=t.unpack(n,0,C);let R=0;for(s=3,l=1;l<G;l++)L=t.clone(C,L),C=t.unpack(n,s,C),R+=t.distance(L,C),s+=3;let u;s=3;let V=0,Ht=0,b=0,Tt=0,W=!1,st=t.unpack(r,0,Ue),lt=t.unpack(n,0,re),Z=t.unpack(i,0,Ze);if(e){let ht=t.unpack(r,r.length-6,We);ze(Z,ht,st,lt)&&(Z=t.negate(Z,Z))}let fe=0,de=0,Ut=0;for(l=0;l<f;l++){let ht=t.clone(st,We),qt=t.clone(lt,Ge),mt=t.clone(Z,Pn);W&&(mt=t.negate(mt,mt)),st=t.unpack(r,s,Ue),lt=t.unpack(n,s,re),Z=t.unpack(i,s,Ze),W=ze(Z,ht,st,lt),x.latitude=a[V],x.longitude=a[V+1],I.latitude=a[V+2],I.longitude=a[V+3];let ft,gt,ot,it;if(c){let _=bn(x,I);ft=o.project(x,Yn),gt=o.project(I,Fn);let wt=nt(gt,ft,Ve);wt.y=Math.abs(wt.y),ot=ae,it=ce,_===0||t.dot(wt,t.UNIT_Y)>Ke?(ot=Dt(o,x,mt,ft,ae),it=Dt(o,I,Z,gt,ce)):_===1?(it=Dt(o,I,Z,gt,ce),ot.x=0,ot.y=h.sign(x.longitude-Math.abs(I.longitude)),ot.z=0):(ot=Dt(o,x,mt,ft,ae),it.x=0,it.y=h.sign(x.longitude-I.longitude),it.z=0)}let ge=t.distance(qt,lt),ue=Ct.fromCartesian(ht,Vn),kt=t.subtract(st,ht,Gn),an=t.normalize(kt,qe),Et=t.subtract(qt,ht,Wn);Et=t.normalize(Et,Et);let ut=t.cross(an,Et,qe);ut=t.normalize(ut,ut);let yt=t.cross(Et,mt,Zn);yt=t.normalize(yt,yt);let Mt=t.subtract(lt,st,Un);Mt=t.normalize(Mt,Mt);let Rt=t.cross(Z,Mt,qn);Rt=t.normalize(Rt,Rt);let cn=ge/R,sn=fe/R,Vt=0,xt,bt,dt,we=0,Se=0;if(c){Vt=t.distance(ft,gt),xt=Ct.fromCartesian(ft,$n),bt=t.subtract(gt,ft,Ve),dt=t.normalize(bt,Jn);let _=dt.x;dt.x=dt.y,dt.y=-_,we=Vt/z,Se=de/z}for(u=0;u<8;u++){let _=Tt+u*4,wt=Ht+u*2,It=_+3,_e=u<4?1:-1,Pt=u===2||u===3||u===6||u===7?1:-1;t.pack(ue.high,v,_),v[It]=kt.x,t.pack(ue.low,X,_),X[It]=kt.y,t.pack(yt,p,_),p[It]=kt.z,t.pack(Rt,F,_),F[It]=cn*_e,t.pack(ut,B,_);let pt=sn*Pt;pt===0&&Pt<0&&(pt=9),B[It]=pt,c&&(M[_]=xt.high.x,M[_+1]=xt.high.y,M[_+2]=xt.low.x,M[_+3]=xt.low.y,N[_]=-ot.y,N[_+1]=ot.x,N[_+2]=it.y,N[_+3]=-it.x,k[_]=bt.x,k[_+1]=bt.y,k[_+2]=dt.x,k[_+3]=dt.y,y[wt]=we*_e,pt=Se*Pt,pt===0&&Pt<0&&(pt=9),y[wt+1]=pt)}let $=jn,J=Xn,K=Bn,Q=zn,ln=Y.fromCartographicArray(An,vn),Te=Xt.getMinimumMaximumHeights(ln,d),$t=Te.minimumTerrainHeight,Jt=Te.maximumTerrainHeight;Ut+=Math.abs($t),Ut+=Math.abs(Jt),Fe(ht,qt,$t,Jt,$,K),Fe(st,lt,$t,Jt,J,Q);let tt=t.multiplyByScalar(ut,h.EPSILON5,$e);t.add($,tt,$),t.add(J,tt,J),t.add(K,tt,K),t.add(Q,tt,Q),Gt($,J),Gt(K,Q),t.pack($,D,b),t.pack(J,D,b+3),t.pack(Q,D,b+6),t.pack(K,D,b+9),tt=t.multiplyByScalar(ut,-2*h.EPSILON5,$e),t.add($,tt,$),t.add(J,tt,J),t.add(K,tt,K),t.add(Q,tt,Q),Gt($,J),Gt(K,Q),t.pack($,D,b+12),t.pack(J,D,b+15),t.pack(Q,D,b+18),t.pack(K,D,b+21),V+=2,s+=3,Ht+=16,b+=24,Tt+=32,fe+=ge,de+=Vt}s=0;let pe=0;for(l=0;l<f;l++){for(u=0;u<Je;u++)O[s+u]=rn[u]+pe;pe+=8,s+=Je}let Zt=Kn;U.fromVertices(r,t.ZERO,3,Zt[0]),U.fromVertices(n,t.ZERO,3,Zt[1]);let me=U.fromBoundingSpheres(Zt);me.radius+=Ut/(f*2);let _t={position:new zt({componentDatatype:Bt.DOUBLE,componentsPerAttribute:3,normalize:!1,values:D}),startHiAndForwardOffsetX:at(v),startLoAndForwardOffsetY:at(X),startNormalAndForwardOffsetZ:at(p),endNormalAndTextureCoordinateNormalizationX:at(F),rightNormalAndTextureCoordinateNormalizationY:at(B)};return c&&(_t.startHiLo2D=at(M),_t.offsetAndRight2D=at(k),_t.startEndNormals2D=at(N),_t.texcoordNormalization2D=new zt({componentDatatype:Bt.FLOAT,componentsPerAttribute:2,normalize:!1,values:y})),new Ie({attributes:_t,indices:O,boundingSphere:me})}function at(e){return new zt({componentDatatype:Bt.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}ct._projectNormal=Dt;var he=ct;function to(e,o){return Xt.initialize().then(function(){return m(o)&&(e=he.unpack(e,o)),he.createGeometry(e)})}var ti=to;export{ti as default};
